상속(inheritance)
	1. 기존에 선언된 클래스의 필드를 새롭게 만들 클래스의 필드로 사용하고자 	   할 때
	2. 여러 클래스 선언 시 필드가 겹치면, 부모 클래스를 먼저 선언하고
	   공통 필드를 묶어서 각 자식 클래스들에게 상속해준다.

상속 문법
	class A{
		A 필드
	}
	class B extends A {
		B 필드 --> A, B 필드로 바뀐다.
	}
	A : 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
	B : 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스

super() : 부모 생성자
		자식 클래스 타입의 객체는 부모 필드에 접근할 수 있다.
		하지만 자식 생성자만 호출하기 때문에, 자식 필드만 메모리 할당
		그렇기 때문에 B타입의 객체로 A필드(부모 필드)에 접근할 수 없어야 		정상	
		사실 자식 생성자에서 항상 부모 생성자를 호출하기 때문에
		자식 생성자 호출 시 부모와 자식 필드 모두 메모리에 할당된다.
		이 때, 부모 생성자를 호출하는 방법은 super()을 사용하는 것이다.
		만약, super()를 작성하지 않더라도 컴파일러가 자동으로 작성
		반드시 코드 맨 첫 줄에 작성하고 시작해야 한다.

접근 권한 제어자(접근자)
	1. default(생략가능) 다른 패키지에서 접근 불가	
	2. public	모든 곳에서 접근 가능(프로젝트 안에서) 만약 클래스 앞에
			붙인다면 해당 파일의 메인 클래스를 의미한다.
	3. protected	다른 패키지에서 접근 불가, 단 자식은 접근 가능 
	4. private	다른 클래스조차도 접근 불가, 자식도 불가
 
private 목적 
	1. private 접근하지마라 2. 직접 접근하지말고 메소드로 접근해라
	주로 메소드로 접근하기 위해 사용돤다.
	화면에서 해당 필드를 접근하는 방법은 오로지 메소드뿐이다.
	private접근자를 붙이고 외부에서 접근할 수 있도록 public 메소드를		만들어 놓는 것이 모델링 컨벤션이야.
	이 때 public 메소드는 2가지이고, 각각 getter, setter라고 한다.
	이제부터는 정보를 담아놓을 클래스를 선언할 때, 각 변수 앞에 private를		붙여주고 이를 접근할 수 있도록 public 접근자로 getter, setter를 선언
